// import { compile as compileTypescript } from 'json-schema-to-typescript';
import { existsSync } from 'fs';
import { mkdir, readFile, writeFile } from 'fs/promises';
import { resolve } from 'path';
import { format } from 'prettier';

import { ControllerSchema } from '../parse-controller-schema';
import { transformController } from '../transformer/controller';
import { GeneratorOptions, ucFirst } from '../utils';
import { generateControllers } from './controller';
import { generateInterface } from './interfaces';
import { generateSchemas } from './schemas';

export async function generate(options: GeneratorOptions, schema: ControllerSchema) {
    const interfaces = await generateInterface(options, schema.routeGroups);
    const controllers = await generateControllers(options, schema.routeGroups);
    const schemas = await generateSchemas(options, schema.routeGroups);

    const groupNames = [...schema.routeGroups.keys()];
    await Promise.all(
        groupNames.map(async groupName => {
            const path = resolve(schema.version, options.outDirectory);
            const controllersPath = resolve(path, 'controllers', groupName);
            const groupUcFirst = ucFirst(groupName);

            console.log('Creating dirs...', path);

            await mkdir(controllersPath, { recursive: true });

            const typesPath = resolve(controllersPath, 'types.ts');

            const groupInterfaces = interfaces.get(groupName)!;

            let typesContent = `
                /* eslint-disable @typescript-eslint/no-empty-interface */

                /**
                 * This file is auto-generated by . Please do not modify it manually.
                  */
            `;

            const interfaceNames: string[] = [];

            groupInterfaces.forEach(groupInterface => {
                typesContent += `
                    ${groupInterface.params || ''}

                    ${groupInterface.query || ''}

                    ${groupInterface.body || ''}

                    ${groupInterface.response || ''}
                `;

                interfaceNames.push(
                    ...([
                        groupInterface.names.params,
                        groupInterface.names.body,
                        groupInterface.names.query,
                        groupInterface.names.response,
                    ].filter(Boolean) as string[])
                );
            });

            console.log('typesContent=', typesContent);

            typesContent = format(typesContent, options.prettierOptions);

            console.log('Writing types.ts...', typesPath, typesContent.length, 'bytes');
            await writeFile(typesPath, typesContent, { flag: 'w' });

            const controllerPath = resolve(controllersPath, `${groupName}.controller.ts`);
            const controllerCode = controllers.get(groupName)!;

            controllerCode.imports.addImport('fastify-decorators', 'Controller');

            const controllerClass = `${groupUcFirst}Controller`;

            if (existsSync(controllerPath)) {
                console.log('Controller already exists! Analysing and rewriting...');
                const oldControllerCode = await readFile(controllerPath, 'utf-8');
                const newControllerCode = format(
                    transformController(oldControllerCode, {
                        className: controllerClass,
                        imports: controllerCode.imports.asRecord(),
                        methods: controllerCode.methods,
                    }),
                    options.prettierOptions
                );

                console.log('Writing controller...', controllerPath, newControllerCode.length, 'bytes');
                await writeFile(controllerPath, newControllerCode, { flag: 'w' });
            } else {
                const controllerImportsText = controllerCode.imports.generate();

                const controllerContent = format(
                    `
                    ${controllerImportsText}

                    @Controller({ route: '/${groupName}' })
                    export default class ${groupUcFirst}Controller {
                        ${controllerCode.inClassBody}   
                    }
                `,
                    options.prettierOptions
                );
                console.log('Writing controller...', controllerPath, controllerContent.length, 'bytes');
                await writeFile(controllerPath, controllerContent, { flag: 'w' });
            }

            const schemasPath = resolve(controllersPath, 'schemas.ts');
            const groupSchemas = schemas.get(groupName)!;

            const schemasContent = format(
                `
                /**
                 * This file is auto-generated by . Please do not modify it manually.
                 */
                ${groupSchemas.imports}

                ${groupSchemas.routes
                    .map(
                        e => `
                            export interface ${e.schemaTypeName} ${e.schemaTypeContent};
                            export const ${e.schemaObjectName} = ${e.schemaObjectContent};
                        `
                    )
                    .join('\n')}
            `,
                options.prettierOptions
            );

            console.log('Writing schemas.ts...', schemasPath, schemasContent.length, 'bytes');
            await writeFile(schemasPath, schemasContent, { flag: 'w' });
        })
    );
}
